module fluid.text;

import std.math;
import std.range;
import std.algorithm;

import fluid.node;
import fluid.style;
import fluid.backend;
import fluid.typeface;


@safe:


/// Create a Text struct with given range as a text layer map.
Text!(T, LayerRange) mapText(T : Node, LayerRange)(T node, const char[] text, LayerRange range, size_t layerCount) {

    return typeof(return)(node, text, range, layerCount);

}

/// Draws text: handles updates, formatting and styling.
struct Text(T : Node, LayerRange = TextRange[]) {

    static assert(isForwardRange!(LayerRange, TextRange), "LayerRange must be a valid forward TextRange range");

    public {

        /// Node owning this text struct.
        T node;

        /// Textures generated by the struct.
        CompositeTexture[] textures;

        /// Underlying text.
        const(char)[] value;

        /// Range determining layers in the text.
        ///
        /// Ranges should not overlap, and must be ordered by `start`. If a piece of text is not matched, it is assumed
        /// to belong to layer 1.
        LayerRange layerMap;

    }

    private {

        /// Text bounding box size, in dots.
        Vector2 _sizeDots;

        /// If true, text will be wrapped if it doesn't fit available space.
        bool _wrap;

    }

    alias minSize = size;
    alias value this;

    static if (is(LayerRange == TextRange[]))
    this(T node, const(char)[] text) {

        this.node = node;
        this.textures = new CompositeTexture[1];
        opAssign(text);

    }

    this(T node, const(char)[] text, LayerRange layerMap, size_t layerCount) {

        this.node = node;
        this.textures = new CompositeTexture[layerCount];
        this.layerMap = layerMap;
        opAssign(text);

    }

    /// Copy the text, clear ownership and texture.
    this(Text text) const {

        this.node = null;
        this.textures = new CompositeTexture[text.textures.length];
        this.value = text.value;
        this.layerMap = text.layerMap.save;

    }

    inout(FluidBackend) backend() inout

        => node.tree.backend;


    const(char)[] opAssign(const(char)[] text) {

        // Ignore if there's no change to be made
        if (text == value) return text;

        // Request update otherwise
        node.updateSize;
        return value = text;

    }

    const(char)[] opOpAssign(string operator)(const(char)[] text) {

        node.updateSize;
        return mixin("value ", operator, "= text");

    }

    /// Get the size of the text.
    Vector2 size() const {

        const scale = backend.hidpiScale;

        return Vector2(
            _sizeDots.x / scale.x,
            _sizeDots.y / scale.y,
        );

    }

    /// Set or get the number of layers generated. Extra layers make it possible to apply different styles to different
    /// parts of the text, but slow down the process.
    ///
    /// Note: Due to present limitations in the implementation, it is not currently possible to mix different typefaces
    /// within the same Text.
    size_t layerCount() const {

        return textures.length;

    }

    /// ditto
    size_t layerCount(size_t i) {

        return textures.length = i;

    }

    alias minSize = size;

    /// Set new bounding box for the text.
    void resize() {

        auto style = node.pickStyle;
        auto dpi = backend.dpi;

        style.setDPI(dpi);

        // Update the size
        _sizeDots = style.getTypeface.measure(value);
        _wrap = false;

        // Create new textures
        textures[] = CompositeTexture(_sizeDots);

    }

    /// Set new bounding box for the text; wrap the text if it doesn't fit in boundaries.
    void resize(alias splitter = Typeface.defaultWordChunks)(Vector2 space, bool wrap = true) {

        auto style = node.pickStyle;
        auto dpi = backend.dpi;
        auto scale = backend.hidpiScale;

        // Apply DPI
        style.setDPI(dpi);
        space.x *= scale.x;
        space.y *= scale.y;

        // Update the size
        _sizeDots = style.getTypeface.measure!splitter(space, value, wrap);
        _wrap = wrap;

        // Create new textures
        textures[] = CompositeTexture(_sizeDots);

    }

    /// Generate the textures, if not already generated.
    ///
    /// Params:
    ///     chunks = Indices of chunks that need to be regenerated. Optional; Defaults to on-screen chunks.
    void generate() {

        // No textures to generate, nothing to do
        if (textures.length == 0) return;

        generate(textures[0].visibleChunks);

    }

    /// ditto
    void generate(R)(R chunks) @trusted {

        // Empty, nothing to do
        if (chunks.empty) return;

        // No textures to generate, nothing to do
        if (textures.length == 0) return;

        const style = node.pickStyle;
        const typeface = style.getTypeface;
        const dpi = node.backend.dpi;

        // Ignore chunks which have already been generated
        auto newChunks = chunks
            .filter!(index => textures[0].textures[index] == TextureGC.init);

        // Prepare images to use as target
        auto images = textures

            // For each layer, generate chunks
            .map!(a => newChunks

                // Generate blank image for each texture
                .map!(index => generateColorImage(
                    cast(int) a.chunkSize(index).x,
                    cast(int) a.chunkSize(index).y,
                    color("#0000")))
                .array)

            .array;

        auto ruler = TextRuler(typeface, _sizeDots.x);

        // Copy the layer range, make it infinite
        auto layerMap = this.layerMap.save.chain(TextRange.init.repeat);

        // Run through the text
        foreach (index, line; Typeface.lineSplitterIndex(value)) {

            ruler.startLine();

            // Split on words
            // TODO use the splitter provided when resizing
            foreach (word, penPosition; Typeface.eachWord(ruler, line, _wrap)) {

                const wordEnd = index + word.length;

                // Split the word based on the layer map
                while (index != wordEnd) {

                    const remaining = wordEnd - index;
                    auto wordFragment = word[$ - remaining .. $];
                    auto range = layerMap.front;

                    // Advance the layer map if exceeded the end
                    if (index >= range.end) {
                        layerMap.popFront;
                        continue;
                    }

                    size_t layer = 0;

                    // Match found here
                    if (index >= range.start) {

                        // Find the end of the range
                        const end = min(wordEnd, range.end) - index;
                        wordFragment = wordFragment[0 .. end];
                        layer = range.layer;

                    }

                    // Match found later
                    else if (range.start < wordEnd) {

                        wordFragment = wordFragment[0 .. range.start - index];

                    }

                    // Redirect unknown layers to first layer
                    if (layer > textures.length) layer = 0;

                    const currentPenPosition = penPosition;

                    // Draw the fragment to selected chunks
                    foreach (i, chunkIndex; newChunks.enumerate) {

                        const composite = textures[layer];
                        const start = composite.chunkPosition(chunkIndex);
                        auto relativePenPosition = currentPenPosition - start;

                        // TODO don't draw if the chunk isn't relevant

                        typeface.drawLine(images[layer][i], relativePenPosition, wordFragment, color("#fff"));

                        // Update the pen position
                        if (chunkIndex == 0) penPosition = relativePenPosition + start;

                    }

                    // Update the index
                    index += wordFragment.length;

                }

            }

        }

        // Load textures
        foreach (i, ref composite; textures) {

            foreach (imageIndex, chunkIndex; newChunks.enumerate) {

                // Load texture
                composite.textures[chunkIndex] = TextureGC(backend, images[i][imageIndex]);
                composite.textures[chunkIndex].dpiX = cast(int) dpi.x;
                composite.textures[chunkIndex].dpiY = cast(int) dpi.y;

                // Destroy the image
                images[i][imageIndex].destroy();

            }

        }

    }

    /// Draw the text.
    void draw(const Style style, Vector2 position) {

        scope const Style[1] styles = [style];

        draw(styles, position);

    }

    /// ditto
    void draw(scope const Style[] styles, Vector2 position)
    in (styles.length, "No styles were passed to draw(Style[], Vector2)")
    do {

        import std.math;
        import fluid.utils;

        const rectangle = Rectangle(position.tupleof, size.tupleof);
        const screen = Rectangle(0, 0, node.io.windowSize.tupleof);

        // Ignore if offscreen
        if (!overlap(rectangle, screen)) return;

        // Regenerate visible textures
        generate();

        // Draw the texture if present
        foreach (i, ref texture; textures) {

            if (texture is texture.init) continue;

            auto style = i < styles.length
                ? styles[i]
                : styles[0];

            texture.drawAlign(backend, rectangle, style.textColor);

        }

    }

    /// ditto
    deprecated("Use draw(Style, Vector2) instead. Hint: Use fluid.utils.start(Rectangle) to get the position vector.")
    void draw(const Style style, Rectangle rectangle) {

        // Should this "crop" the result?

        draw(style, Vector2(rectangle.x, rectangle.y));

    }

    string toString() const {

        return value.idup;

    }

}

struct TextRange {

    /// Start and end of this range. Start is inclusive, end is exclusive. The range may exceed text boundaries.
    auto start = size_t.max;

    /// ditto
    auto end = size_t.max;

    invariant(start <= end);

    /// Layer the text matched by this range is assigned to. The layer should be a valid index into `Text.textures`.
    size_t layer;

    ptrdiff_t opCmp(const TextRange that) const {

        return cast(ptrdiff_t) this.start - cast(ptrdiff_t) that.start;

    }

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();
    auto text = Text!Space(root, "Hello, green world!");

    // Set colors for each part
    Style[4] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");
    styles[2].textColor = color("#55b9ff");
    styles[3].textColor = color("#0058f1");

    // Define regions
    text.layerCount = styles.length;
    text.layerMap = [
        TextRange(7, 12, 1),   // green
        TextRange(13, 14, 2),  // w
        TextRange(14, 15, 3),  // o
        TextRange(15, 16, 2),  // r
        TextRange(16, 17, 3),  // l
        TextRange(17, 18, 2),  // d
    ];

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize();
    text.draw(styles, Vector2(0, 0));

    // Make sure each texture was drawn with the rigth color
    foreach (i; 0..4) {

        io.assertTexture(text.textures[i].texture, Vector2(), styles[i].textColor);

    }

    // TODO Is there a way to reliably test if the result was drawn properly? Sampling specific pixels maybe?

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();

    Style[2] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");

    auto layers = recurrence!"a[n-1] + 1"(0)
        .map!(a => TextRange(a, a+1, a % 2));

    auto text = mapText(root, "Hello, World!", layers, styles.length);

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize(Vector2(50, 50));
    text.draw(styles, Vector2(0, 0));

}

unittest {

    import fluid.space;

    auto io = new HeadlessBackend;
    auto root = vspace();

    Style[2] styles;
    styles[0].textColor = color("#000000");
    styles[1].textColor = color("#1eff00");

    auto layers = [
        TextRange(2, 11, 1),
    ];

    auto text = mapText(root, "Hello, World!", layers, styles.length);

    // Prepare the tree
    root.io = io;
    root.draw();

    // Draw the text
    io.nextFrame;
    text.resize(Vector2(60, 50));
    text.draw(styles, Vector2(0, 0));

}

unittest {

    import fluid.space;

    Style[2] styles;
    auto root = vspace();
    auto layers = [
        TextRange(0, 0, 1),
    ];
    auto text = mapText(root, "Hello, World!", layers, styles.length);

    root.draw();
    text.resize();
    text.draw(styles, Vector2(0, 0));

}

/// A composite texture splits a larger area onto smaller chunks, making rendering large pieces of text more efficient.
struct CompositeTexture {

    enum maxChunkSize = 1024;

    /// Total size of the texture.
    Vector2 size;

    /// Underlying textures.
    ///
    /// Each texture, except for the last in each column or row, has the size of maxChunkSize on each side. The last
    /// texture in each row and column may have reduced width and height respectively.
    TextureGC[] textures;

    this(Vector2 size) {

        this.size = size;

        const chunkCount = columns * rows;

        this.textures = new TextureGC[chunkCount];

    }

    size_t chunkCount() const {

        return textures.length;

    }

    size_t columns() const {

        return cast(size_t) ceil(size.x / maxChunkSize);

    }

    size_t rows() const {

        return cast(size_t) ceil(size.y / maxChunkSize);

    }

    size_t column(size_t i) const {

        return i % columns;

    }

    size_t row(size_t i) const {

        return i / columns;

    }

    /// Get the expected size of the chunk at given index
    Vector2 chunkSize(size_t i) const {

        const x = column(i);
        const y = row(i);

        // Reduce size for last column
        const width = x + 1 == columns
            ? size.x % maxChunkSize
            : maxChunkSize;

        // Reduce size for last row
        const height = y + 1 == rows
            ? size.y % maxChunkSize
            : maxChunkSize;

        return Vector2(width, height);

    }

    /// Get index of the chunk at given X or Y.
    size_t index(size_t x, size_t y) const
    in (x < columns)
    in (y < rows)
    do {

        return x + y * columns;

    }

    /// Get position of the given chunk
    Vector2 chunkPosition(size_t i) const {

        const x = column(i);
        const y = row(i);

        return maxChunkSize * Vector2(x, y);

    }

    /// Get a range of indices for all currently visible chunks.
    const visibleChunks() {

        const rowStart = 0;
        const rowEnd = rows;
        const columnStart = 0;
        const columnEnd = columns;

        // For each row
        return iota(rowStart, rowEnd)
            .map!(row =>

                // And each column
                iota(columnStart, columnEnd)

                    // Get its index
                    .map!(column => index(column, row)))
            .joiner;

    }

    /// Draw onscreen parts of the texture.
    void drawAlign(FluidBackend backend, Rectangle rectangle, Color tint = color("#fff")) {

        import fluid.utils : start;

        // TODO draw onscreen only

        foreach (index; visibleChunks) {

            const position = rectangle.start + chunkPosition(index);
            const size = chunkSize(index);
            const rect = Rectangle(position.tupleof, size.tupleof);

            backend.drawTextureAlign(textures[index], rect, tint);

        }

    }

}
